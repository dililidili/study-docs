# 2.2、优化表设置-索引

## 1.介绍

- 索引是帮助MySQL高效获取数据的数据结构
- 索引存储在文件系统中(磁盘)
- 索引文件的存储形式与存储引擎有关
- 索引文件结构:hash、二叉树、B树、B+树

## 2.执行过程

1. 第一步客户端：发送请求
2. 第二步连接器：连接数据库
3. 第三步分析器：此法分析，语法分析
4. 第四步优化器：优化SQL语句，规定执行流程
5. 第五步执行器：SQL语句的实际执行组件
6. 第六步存储引擎：不同的存放位置，不同的存储格式;(InnoDB、MyISAM、memory)

## 3.存储引擎

MySQL主流存储引擎：**InnoDB、MyISAM、memory**

### 1.区别

1. #### 存放方式区别：

   - InnoDB：存放磁盘
   - MyISAM：存放磁盘
   - memory：存放内存

2. #### 索引分类：

   - InnoDB：聚簇索引（数据和索引存放在一个文件中）

     - .frm：存放表结构
     - .ibd：存放数据及索引

     > innoDB默认数据及索引存储在表空间中,不会单独文件存储,如果需要可手动开启。
     >
     > 查看开启状态：show variables like '%per_table%';
     >
     > 开启：set global innodb_file_per_table = on;

   - MyISAM：非聚簇索引（数据和索引存放在不同的文件中）

     - .frm：存放表结构
     - .MYD：存放数据
     - .MYI：存放索引

3. #### 区别：

| 特点       | InnoDB           | MyISAM | MEMORY | MERGE | NDB  |
| ---------- | ---------------- | ------ | ------ | ----- | ---- |
| 存储限制   | 64TB             | 有     | 有     | 没有  | 有   |
| 事物安全   | 支持             |        |        |       |      |
| 锁机制     | 行锁(适合高并发) | 表锁   | 表锁   | 表锁  | 行锁 |
| B树索引    | 支持             | 支持   | 支持   | 支持  | 支持 |
| 哈希索引   |                  | 支持   |        |       |      |
| 全文索引   | 5.6后支持        | 支持   |        |       |      |
| 集群索引   | 支持             |        |        |       |      |
| 数据索引   | 支持             |        | 支持   |       | 支持 |
| 索引缓存   | 支持             | 支持   | 支持   | 支持  | 支持 |
| 数据可压缩 |                  | 支持   |        |       |      |
| 空间使用   | 高               | 低     |        | 低    | 低   |
| 内存使用   | 高               | 低     | 中等   | 低    | 高   |
| 插入速度   | 低               | 高     | 高     | 高    | 高   |
| 支持外健   | 支持             |        |        |       |      |



### 4.索引数据结构

#### **1.哈希表**

​		hash表每次在添加索引的时候需要计算指定列的hash值，取模运算后计算出下标，将元素插入下标位置。

适用场景

1. 等值查询。（表数据是无序数据，范围查询效率比较低，需要挨个进行遍历）

- 企业中多数的查询为范围查询所以不推荐使用。
- 而且hash表在使用时需要将全部数据加载到内存中，比较浪费内存空间。

#### 2.二叉树

​		二叉树及其衍生的树都不能支撑索引，原因：树的深度无法控制和插入数据性能低。

#### 3.AVL树、平衡树

​		AVL树是严格意义上的平衡树，最高子树和最低子树高度差不能超过1，因此在插入的时候会进行1～N次的旋转，严重影响插入性能。

#### 4.红黑树

​		红黑树是基于AVL树的升级，损失了部分查询性能来提升插入性能，红黑树最高子树和最低子树高度差小于2倍即可，在插入时不需要进行N多次旋转，且加入了变色特性来满足查询和插入性能的平衡。

#### 5.B树

​		非叶子节点会存储一个key和一个data，每个节点都有一个key，同时也存储一个data，而每个页存储空间有限，如果data比较大的话会导致每个节点存储的key变少，而导致节点变多，深度变大，影响查询效率。

#### 6.B+树(目前索引正在使用的数据结构)

B+树是B树的升级	

- 为了降低树的高度，将数据范围变多个区间，区间越多，数据检索越快。
- 非叶子节点只存储key不再存储data，叶子节点存储key和数据。
- 叶子节点指针相互指向（链式环结构），顺序查询性能更高，支持主键范围和分页查询，支持从根节点随机查询。

##### 注意点：

- B+树默认根据主键创建，根据主键查找数据，主键B+树叶子节点直接存储data，如果其他字段创建唯一索引那么叶子节点存储的是主键，需要再去主键B+树中再检索一遍(非唯一索引查询需要扫描2个B+树)，此操作称为回表。

### 5.索引分类

MySQL索引的五种类型：主键索引、唯一索引、普通索引、全文索引、组合索引

- ##### 主键索引

  主键是一种唯一性索引，但它必须指定为PRIMARY KEY，每个表只能有一个主键。

- ##### 唯一索引

  索引列的所有值都只能出现一次，即必须唯一，值可以为空。

- ##### 普通索引

  普通的索引类型，值可以为空，没有唯一性限制(覆盖索引)。

- ##### 全文索引(MyISAM支持,Innodb5.6后支持)

  全文索引类型为FULLTEXT。全文索引可以在varchar、char、text类型上建立。

- ##### 组合索引

  多列值组成一个索引，用于组合搜索(最左匹配原则)。

> 覆盖索引：根据索引列去查询主键的情况下不会进行回表。
>
> 最左匹配原则：
>
>     将a,b设置成联合索引ab,则命中索引规则如下：
>     where a=6;走索引
>     where a=6 and b=1;走索引
>     where b=1;            不走索引
>     where a like 'a%' ;   走索引
>     where a like '%a%';   不走索引
>     where a like 'a%' and b=‘2’; a 走索引，b 不走索引
>     将 a,b,c设置成联合索引abc： 
>     a、ab、abc走索引，其他情况不走索引



### 6.索引下推

​		索引下推的目的是为了减少回表次数，也就是要减少IO操作。

#### **适用条件：**

1. 需要整表扫描的情况。比如：range, ref, eq_ref, ref_or_null 。适用于InnoDB 引擎和 MyISAM 引擎的查询。（5.6版本不适用分区表查询，5.7版本后可以用于分区表查询）。
2. 对于InnDB引擎只适用于二级索引，因为InnDB的聚簇索引会将整行数据读到InnDB的缓冲区，这样一来索引条件下推的主要目的减少IO次数就失去了意义。因为数据已经在内存中了，不再需要去读取了。
3. 引用子查询的条件不能下推。
4. 调用存储过程的条件不能下推，存储引擎无法调用位于MySQL服务器中的存储过程。
   触发条件不能下推。

#### **用处**

​		当使用索引条件下推优化时，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。

#### **工作过程**

- **不使用索引条件下推优化时的查询过程**
  - 获取下一行，首先读取索引信息，然后根据索引将整行数据读取出来。
  - 然后通过where条件判断当前数据是否符合条件，符合返回数据。
- **使用索引条件下推优化时的查询过程**
  - 获取下一行的索引信息。
  - 检查索引中存储的列信息是否符合索引条件，如果符合将整行数据读取出来，如果不符合跳过读取下一行。
  - 用剩余的判断条件，判断此行数据是否符合要求，符合要求返回数据。



