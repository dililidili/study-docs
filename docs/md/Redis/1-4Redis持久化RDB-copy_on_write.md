# 1.Redis持久化RDB- copy on write

**1、RDB过程中会fork一个子进程，子进程做数据备份操作，主进程继续对外提供服务，所有Redis服务不会阻塞；**
**2、Copy On Write 机制，备份的是开始那个时刻内存中的数据；**
**3、Copy On Write 机制不需要把整个内存的数据都复制一份；**



## Copy On Write 机制

> **核心思路**：fork一个子进程，只有在父进程发生写操作修改内存数据时，才会真正去分配内存空间，并复制内存数据，而且也只是复制被修改的内存页中的数据，并不是全部内存数据；

- Redis中执行BGSAVE命令生成RDB文件时，本质就是调用Linux中的fork()命令，Linux下的fork()系统调用实现了copy-on-write写时复制；
- fork()是类Unix操作系统上创建线程的主要方法，fork用于**创建子进程**（等同于当前进程的副本）；
- **传统的**普通进程复制，会直接将父进程的数据拷贝到子进程中，拷贝完成后，父进程和子进程之间的**数据段**和**堆栈**是相互独立的；
- copy-on-write技术，在fork出子进程后，与父进程共享内存空间，两者只是虚拟空间不同，但是其对应的物理空间是同一个；

## Linux中CopyOnWrite实现原理

fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会把触发的异常的页复制一份，于是父子进程各自持有独立的一份。

**CopyOnWrite的好处：**

**1、减少分配和复制资源时带来的瞬时延迟；**
**2、减少不必要的资源分配；**

**CopyOnWrite的缺点：**

**1、如果父子进程都需要进行大量的写操作，会产生大量的分页错误（页异常中断page-fault）;**

## Redis中的CopyOnWrite

- Redis在持久化时，如果是采用BGSAVE命令或者BGREWRITEAOF的方式，那**Redis会fork出一个子进程来读取数据，从而写到磁盘中**。
- 总体来看，**Redis还是读操作比较多**。如果子进程存在期间，发生了大量的写操作，那可能就会出现很多的**分页错误(页异常中断page-fault)**，这样就得耗费不少性能在复制上。
- 而在**rehash阶段上，写操作是无法避免**的。所以Redis在fork出子进程之后，**将负载因子阈值提高，尽量减少写操作**，避免不必要的内存写入操作，最大限度地节约内存。